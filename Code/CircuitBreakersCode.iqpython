{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nFlywheel_motor_a = Motor(Ports.PORT8, False)\nFlywheel_motor_b = Motor(Ports.PORT11, True)\nFlywheel = MotorGroup(Flywheel_motor_a, Flywheel_motor_b)\ntouchled_8 = Touchled(Ports.PORT10)\nSlide_motor_a = Motor(Ports.PORT7, True)\nSlide_motor_b = Motor(Ports.PORT12, False)\nSlide = MotorGroup(Slide_motor_a, Slide_motor_b)\ndrive_train_motor_a = Motor(Ports.PORT3, False)\ndrive_train_motor_b = Motor(Ports.PORT4, True)\ndrive_train = MotorGroup(drive_train_motor_a, drive_train_motor_b)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_left_shoulder_control_motors_stopped = True\ncontroller_right_shoulder_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller\ndef rc_auto_loop_function_controller():\n    global controller_left_shoulder_control_motors_stopped, controller_right_shoulder_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonLUp/buttonLDown status\n            # to control Slide\n            if controller.buttonLUp.pressing():\n                Slide.spin(FORWARD)\n                controller_left_shoulder_control_motors_stopped = False\n            elif controller.buttonLDown.pressing():\n                Slide.spin(REVERSE)\n                controller_left_shoulder_control_motors_stopped = False\n            elif not controller_left_shoulder_control_motors_stopped:\n                Slide.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_left_shoulder_control_motors_stopped = True\n            # check the buttonRUp/buttonRDown status\n            # to control Flywheel\n            if controller.buttonRUp.pressing():\n                Flywheel.spin(FORWARD)\n                controller_right_shoulder_control_motors_stopped = False\n            elif controller.buttonRDown.pressing():\n                Flywheel.spin(REVERSE)\n                controller_right_shoulder_control_motors_stopped = False\n            elif not controller_right_shoulder_control_motors_stopped:\n                Flywheel.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_right_shoulder_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller = Thread(rc_auto_loop_function_controller)\n\n#endregion VEXcode Generated Robot Configuration\n\n\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nintake_spinning = False\ndispense_state=None\n\ncode_number=0\ngear_ratio=4\n\ndef turn_flywheel(waitseconds,seconds):\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(\"STARTED FLYWHEEL\")\n    wait(waitseconds,SECONDS)\n    brain.timer.clear()\n    brain.screen.set_cursor(2,1)\n\n    brain.screen.print(\"FINISHED WAITING\")\n    Flywheel.spin(FORWARD)\n    brain.screen.set_cursor(3,1)\n    brain.screen.print(\"FINISHED FLYWHEEL\")\n    wait(seconds,SECONDS)\n        \n    print(\"FINISHED FLYWHEEL\")\n    Flywheel.stop()\ndef drive_till(direct,dist):\n    drive_train.spin_for(direct,gear_ratio*14.5799715235*dist/2,DEGREES)\ndef turn_till(direct,turn_angle):\n    if direct==RIGHT:\n        drive_train_motor_a.spin_for(FORWARD,turn_angle*gear_ratio,DEGREES)\n    else:\n        drive_train_motor_b.spin_for(FORWARD,turn_angle*gear_ratio,DEGREES)\ndef reverse_turn_till(direct,turn_angle):\n    if direct==RIGHT:\n        drive_train_motor_b.spin_for(REVERSE,turn_angle*gear_ratio,DEGREES)\n    else:\n        drive_train_motor_a.spin_for(REVERSE,turn_angle*gear_ratio,DEGREES)\n\ndef third_auton():\n    global code_number\n    # drivetrain.set_drive_velocity(25,PERCENT)\n    # drivetrain.set_turn_velocity(25,PERCENT)\n\n    code_number+=1\n    def outtake():\n        degrees_needed=1620\n        Slide.spin_for(FORWARD,degrees_needed,DEGREES)\n        wait(0.5,SECONDS)\n        Slide.spin_for(REVERSE,degrees_needed,DEGREES)\n    def get_first_greens():\n        drive_till(FORWARD,25)\n        wait(0.5,SECONDS)\n        drive_till(REVERSE,20.8)\n        reverse_turn_till(LEFT,87)\n        drive_till(REVERSE,11)\n        drive_train.stop()\n        outtake()\n    def get_second_greens():\n        \n        drive_till(FORWARD,11)\n        wait(0.5,SECONDS)\n        drive_till(REVERSE,5)\n        turn_till(RIGHT,90)\n        drive_till(FORWARD,12)\n        drive_till(REVERSE,3.5)\n        turn_till(LEFT,40)\n        drive_till(REVERSE,14.5)\n        turn_till(RIGHT,20)\n        drive_till(REVERSE,4)\n        reverse_turn_till(RIGHT,20)\n        drive_train.stop()\n        outtake()\n    def get_third_greens():\n\n        drive_till(FORWARD,25)\n        wait(1,SECONDS)\n        drive_till(FORWARD,15)\n        # # Get greens by front of goal\n\n        reverse_turn_till(RIGHT,135)\n        drive_till(REVERSE,5.5)\n        reverse_turn_till(RIGHT,45)\n        drive_till(REVERSE,10)\n        drive_train.stop()\n        # drive_till(REVERSE,1)\n\n        # Get greens by side of goal\n        # drive_till(FORWARD,31)\n        # turn_till(RIGHT,95)\n        # drive_till(REVERSE,6)\n\n        outtake()\n    \n    def get_reds_park():\n        drive_till(FORWARD,9)\n        turn_till(LEFT,85)\n        drive_till(FORWARD,70)\n    def third_prog():\n        get_third_greens()\n        knock_reds()\n    def knock_reds():\n        def rest_of_knocking():\n            # reverse_turn_till(LEFT,4)\n            # drive_till(FORWARD,3)\n            # turn_till(LEFT,41)\n            # drive_till(FORWARD,6)\n            # turn_till(LEFT,46)\n            drive_till(FORWARD,7)\n            turn_till(LEFT,95)\n            drive_till(FORWARD,12)\n            # drive_till(FORWARD,35)\n            # turn_till(RIGHT,92)\n            drive_till(FORWARD,5)\n            turn_till(LEFT,45)\n            turn_till(RIGHT,43)\n            drive_till(FORWARD,18)\n            turn_till(LEFT,45)\n            turn_till(RIGHT,45)\n            drive_till(FORWARD,300)\n        # Thread(lambda: turn_flywheel(0,10))\n        Thread(rest_of_knocking)\n\n\n\n        \n\n\n    if code_number==1:\n        Thread(lambda: turn_flywheel(0,6))\n        Thread(get_first_greens())\n    elif code_number==2:\n        Thread(lambda: turn_flywheel(0,4))\n        Thread(get_second_greens)\n    elif code_number==3:\n        Thread(lambda: turn_flywheel(0,6))\n        Thread(third_prog)\n    elif code_number==4:\n        Thread(lambda: turn_flywheel(0,20))\n        Thread(knock_reds)\n    drive_train.stop()\n    # Flywheel.stop()\n    # Slide.stop()\ndef testing():\n    # turn_till(RIGHT,90)\n    def move():\n        drive_till(FORWARD,11)\n        wait(0.5,SECONDS)\n        drive_till(REVERSE,5)\n        turn_till(RIGHT,90)\n        drive_till(FORWARD,12)\n        drive_till(REVERSE,2)\n        turn_till(LEFT,30)\n        drive_till(REVERSE,15)\n        turn_till(RIGHT,15)\n        drive_till(REVERSE,5)\n\n        degrees_needed=1620\n        Slide.spin_for(FORWARD,degrees_needed,DEGREES)\n        wait(0.5,SECONDS)\n        Slide.spin_for(REVERSE,degrees_needed,DEGREES)\n    Thread(lambda: turn_flywheel(0,4))\n    Thread(move)\n\ndef when_started1():\n\n    # drivetrain.stop()\n    global myVariable, vexcode_brain_precision, vexcode_console_precision\n\n    Flywheel.set_velocity(100,PERCENT)\n    Flywheel.set_max_torque(100,PERCENT)\n    drive_train.set_velocity(54,PERCENT)\n    Slide.set_velocity(100,PERCENT)\n    Slide.set_max_torque(100, PERCENT)\n\n    \n\n\n\n    # bumper_6.released(total_auton)\n    # bumper_6.released(part2)\n    touchled_8.released(third_auton)\n    # controller.buttonEUp.pressed(intaking)\n    # controller.buttonFDown.pressed(box_lift)\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"Slide","leftDir":"false","right":"Flywheel","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[8,11],"name":"Flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[10],"name":"touchled_8","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[7,12],"name":"Slide","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[3,4],"name":"drive_train","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}