{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nFlywheel_motor_a = Motor(Ports.PORT8, True)\nFlywheel_motor_b = Motor(Ports.PORT12, False)\nFlywheel = MotorGroup(Flywheel_motor_a, Flywheel_motor_b)\ntouch = Touchled(Ports.PORT10)\nouttake_motor_a = Motor(Ports.PORT7, True)\nouttake_motor_b = Motor(Ports.PORT9, False)\nouttake = MotorGroup(outtake_motor_a, outtake_motor_b)\nDrivetrain_motor_a = Motor(Ports.PORT3, False)\nDrivetrain_motor_b = Motor(Ports.PORT4, True)\nDrivetrain = MotorGroup(Drivetrain_motor_a, Drivetrain_motor_b)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n\n\n# define variables used for controlling motors based on controller inputs\ncontroller_left_shoulder_control_motors_stopped = True\ncontroller_right_shoulder_control_motors_stopped = True\n\n# define a task that will handle monitoring inputs from controller\ndef rc_auto_loop_function_controller():\n    global controller_left_shoulder_control_motors_stopped, controller_right_shoulder_control_motors_stopped, remote_control_code_enabled\n    # process the controller input every 20 milliseconds\n    # update the motors based on the input values\n    while True:\n        if remote_control_code_enabled:\n            # check the buttonLUp/buttonLDown status\n            # to control outtake\n            if controller.buttonLUp.pressing():\n                outtake.spin(REVERSE)\n                controller_left_shoulder_control_motors_stopped = False\n            elif controller.buttonLDown.pressing():\n                outtake.spin(FORWARD)\n                controller_left_shoulder_control_motors_stopped = False\n            elif not controller_left_shoulder_control_motors_stopped:\n                outtake.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_left_shoulder_control_motors_stopped = True\n            # check the buttonRUp/buttonRDown status\n            # to control Flywheel\n            if controller.buttonRUp.pressing():\n                Flywheel.spin(FORWARD)\n                controller_right_shoulder_control_motors_stopped = False\n            elif controller.buttonRDown.pressing():\n                Flywheel.spin(REVERSE)\n                controller_right_shoulder_control_motors_stopped = False\n            elif not controller_right_shoulder_control_motors_stopped:\n                Flywheel.stop()\n                # set the toggle so that we don't constantly tell the motor to stop when\n                # the buttons are released\n                controller_right_shoulder_control_motors_stopped = True\n        # wait before repeating the process\n        wait(20, MSEC)\n\n# define variable for remote controller enable/disable\nremote_control_code_enabled = True\n\nrc_auto_loop_thread_controller = Thread(rc_auto_loop_function_controller)\n\n#endregion VEXcode Generated Robot Configuration\n\n\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nintake_spinning = False\ndispense_state=None\n\nturn_speed=50\ndrive_speed=75\ndrive_kp=1\n\nstop_driving=False\nstop_turning=False\n\n\nfirst_code_done=False\n\nauton_number=0\ndef PID(cur,final,maxSpeed,minSpeed=6):\n\n    maxSpeedDuration = 0\n    if cur<final*maxSpeedDuration:\n        return maxSpeed\n    else:\n        speed = maxSpeed*(final-cur)/(final*(1-maxSpeedDuration))\n        \n        return max(speed,minSpeed)\ndef direction(subtract=False,toAdd=False):\n\n    head = brain_inertial.heading(DEGREES)\n    if subtract:\n        head = head-360\n    if toAdd:\n        head = head+360\n    if head<=180:\n        return head\n    else:\n        return head-360\ndef reverse_direction(head):\n    if head<0:\n        return head+360\n    else:\n        return head\ndef bound(x):\n    if x<=-180:\n        return x+360\n    if x>180:\n        return x-360\n    else:\n        return x\n\ndef drive_till(direct,dist,msg,sp=None):\n    print(\"STARTING TO MOVE\",direct,\":\",msg)\n    global drive_speed\n    global stop_driving\n    if sp==None:\n        sp=drive_speed\n    turn_angle = 360*dist/(13*25.4)\n    # brain_inertial.set_heading(0,DEGREES)\n\n    beginningRotation=brain_inertial.heading()\n    left_pos = Drivetrain_motor_a.position(DEGREES)\n\n    Drivetrain.set_velocity(sp,PERCENT)\n\n    brain_inertial.set_heading(0,DEGREES)\n    print(\"Direct:\",direction())\n\n\n\n    # brain_inertial.set_heading(5,DEGREES)\n\n    if direct==FORWARD:\n        brain_inertial.heading()\n        while Drivetrain_motor_a.position(DEGREES) < left_pos+turn_angle:\n            \n            \n\n            # print(Drivetrain_motor_a.position(DEGREES),left_pos+turn_angle)\n            error = (direction())\n            # print(\"Error\",error)\n            \n\n            error = error * drive_kp\n            # Drivetrain_motor_a.set_velocity(max(sp-error,0),PERCENT)\n            # Drivetrain_motor_b.set_velocity(max(sp+error,0),PERCENT)\n\n            Drivetrain_motor_a.spin(FORWARD,max(sp-error,0),PERCENT)\n            Drivetrain_motor_b.spin(FORWARD,max(sp+error,0),PERCENT)\n\n            # print(\"Motor A:\",Drivetrain_motor_a.velocity(PERCENT))\n            # print(\"Motor B:\",Drivetrain_motor_b.velocity(PERCENT))\n            \n            \n            \n            # Drivetrain.spin(FORWARD)\n\n            if stop_driving:\n                stop_driving=False\n                break\n        print(\"DONE\")\n        Drivetrain.stop()\n    \n    if direct==REVERSE:\n        while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n            \n            \n\n            # print(Drivetrain_motor_a.position(DEGREES),left_pos+turn_angle)\n            # error = (direction())\n            # print(\"Error\",error)\n            \n\n            # error = error * drive_kp\n            # Drivetrain_motor_a.set_velocity(max(drive_speed-error,0))\n            # Drivetrain_motor_b.set_velocity(max(drive_speed+error,0))\n            # print(\"Motor A:\",max(drive_speed-error,0))\n            # print(\"Motor B:\",max(drive_speed+error,0))\n            \n            \n            Drivetrain.spin(REVERSE)\n\n            if stop_driving:\n                stop_driving=False\n                break\n        print(\"DONE\")\n    # if direct==REVERSE:\n    #     while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n\n    #         error = (direction())\n\n    #         error = error * drive_kp\n    #         print(\"Error\",error,\"Prev Error\",prevError)\n    #         Drivetrain_motor_a.set_velocity(max(drive_speed-error,0))\n    #         Drivetrain_motor_b.set_velocity(max(drive_speed+error,0))\n\n    #         print(\"MADE LEfT MOTOR\", drive_speed-error, \"RIGHT MOTOR\",drive_speed+error)\n    #         print(\"--------------------\")\n\n            \n            \n    #         Drivetrain.spin(REVERSE)\n    #         prevError=error\n\n    #     drive_speed=70\n    #     print(\"DONE\")\n\n    # Drivetrain.stop()\n        \n    newRotation = beginningRotation+direction()\n    brain_inertial.set_heading(reverse_direction(bound(newRotation)))\n\n    print(\"ENDING MOVE\",direct)\n\ndef turn_till(direct,dist,minVelocity=6,secondary=False,reset=False,left=None,right=None):\n\n    global turn_speed\n\n    print(\"STARTING TURN\",direct)\n\n    Drivetrain.set_velocity(turn_speed,PERCENT)\n    # brain_inertial.set_heading(0,DEGREES)\n    if reset:\n        brain_inertial.set_heading(0,DEGREES)\n    ogRotation = direction()\n\n        \n\n    print(direction())\n    if left!=None:\n        Drivetrain_motor_a.set_velocity(left,PERCENT)\n    if right!=None:\n        Drivetrain_motor_b.set_velocity(right,PERCENT)\n    if direct==RIGHT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        subtract=False\n        if(direction()>dist):\n            subtract=True\n\n        while direction(subtract)<dist:\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            Drivetrain.set_velocity(PID(direction(subtract)-ogRotation,dist-ogRotation,turn_speed,minSpeed=minVelocity),PERCENT)\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n            \n            Drivetrain_motor_a.spin(FORWARD)\n            Drivetrain_motor_b.spin(REVERSE)\n\n            # print(direction(subtract),dist)\n        # Drivetrain.stop()\n\n\n    if direct==LEFT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        add=False\n        if(direction()<dist):\n            add=True\n        # print(direction(toAdd=add),dist)\n\n        while direction(toAdd=add)>dist:\n            # print(direction(toAdd=add))\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            if not add:\n                Drivetrain.set_velocity(PID(ogRotation-direction(toAdd=add),ogRotation-dist,turn_speed),PERCENT)\n            else:\n                Drivetrain.set_velocity(PID(direction(toAdd=add)-ogRotation,dist-ogRotation,turn_speed),PERCENT)\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n\n            Drivetrain_motor_a.spin(REVERSE)\n            Drivetrain_motor_b.spin(FORWARD)\n\n        # Drivetrain.stop()\n    Drivetrain.stop()\n\n    opposite_direction = RIGHT if direct == LEFT else LEFT\n    \n    print(\"DONE\")\n\n    print(\"ENDING TURN\",direct)\n \ndef auton():\n    global auton_number\n    auton_number+=1\n    if (auton_number==1):\n        first_auton()\n    else:\n        third_auton()\ndef first_auton():\n    def first_purps():\n        drive_till(FORWARD, 650,\"1\",sp=35)\n        wait(1, SECONDS)\n        #Collected cluster\n        turn_till(LEFT, -90,reset=True)\n        drive_till(FORWARD, 1650,\"2\")\n        #Moving forward\n        drive_till(FORWARD,230,\"3\",sp=30)\n        wait(2, SECONDS)\n        #Finished second cluster\n        turn_speed=75\n        turn_till(LEFT,160)\n        drive_till(REVERSE, 750,\"4\")\n        Drivetrain.stop()\n\n        # wait(5, SECONDS)\n        # drive_till(FORWARD, 300,\"5\")\n        # turn_till(LEFT, 10)\n        # test()\n        #Dispenses\n\n        return\n    def intaking():\n        while True:\n            Flywheel.spin(REVERSE)\n    def outake():\n        \n        wait(24, SECONDS)\n        Drivetrain.stop()\n        # stop_driving=True\n        outtake.spin_for(FORWARD, 2, TURNS)\n        Drivetrain.stop()\n        Thread(second_greens)\n\n        wait(10,SECONDS)\n        Drivetrain.stop()\n        outtake.spin_for(FORWARD, 4, TURNS)\n        \n        Drivetrain.stop()\n        wait(0.5,SECONDS)\n        outtake.spin_for(REVERSE,6,TURNS)\n    def second_greens():\n        print(\"Made it to the second greens yay\")\n        drive_till(FORWARD,730,\"6\")\n        turn_till(LEFT,135)\n        drive_till(FORWARD,800,\"7\")\n        turn_till(LEFT,70)\n        drive_till(REVERSE,400,\"8\")\n        Drivetrain.stop()\n        \n        \n        # drive_till(FORWARD,800,\"6\")\n        # turn_till(LEFT,90,left=0)\n        # turn_till(LEFT,0,right=0)\n        # drive_till(FORWARD,1000,\"7\")\n        # turn_till(LEFT,75)\n        # drive_till(REVERSE,300,\"8\")\n        # # drive_till\n        return\n    Thread(intaking)\n    Thread(first_purps)\n    Thread(outake)\ndef third_auton():\n    def outake_2():\n        wait(19,SECONDS)\n        outtake.spin_for(FORWARD,2,TURNS)\n        wait(11,SECONDS)\n        stop_driving=True\n        outtake.spin_for(FORWARD,4,TURNS)\n        wait(0.5,SECONDS)\n\n        Thread(park)\n    def intaking():\n        while True:\n            Flywheel.spin(REVERSE)\n    def third_prog():\n        drive_till(FORWARD,920,\"9\")\n        turn_till(RIGHT,90)\n        drive_till(FORWARD,80,\"10\",sp=25)\n        drive_till(FORWARD,40,\"\")\n        turn_till(LEFT,0)\n        # drive_till(FORWARD,20,\"\")\n        # drive_till(REVERSE,20,\"\")\n        turn_till(RIGHT,90)\n        drive_till(FORWARD,400,\"11\")\n        turn_till(RIGHT,95)\n        drive_till(FORWARD,200,\"12\",sp=25)\n        wait(0.5,SECONDS)\n        turn_till(LEFT,0)\n        drive_till(FORWARD,40,\"\")\n        drive_till(REVERSE,40,\"\")\n        turn_till(RIGHT,135)\n        drive_till(FORWARD,400,\"13\")\n        \n        turn_till(RIGHT,-180,minVelocity=1)\n        turn_till(LEFT,180)\n        drive_till(FORWARD,200,\"14\")\n        turn_till(RIGHT,-90)\n        turn_till(LEFT,-90)\n        drive_till(FORWARD,250,\"\")\n        turn_till(RIGHT,-70)\n        drive_till(REVERSE,100,\"\")\n    def park():\n        drive_till(FORWARD,20,\"\")\n        turn_till(RIGHT,20)\n        turn_till(LEFT,20)\n        drive_till(FORWARD,10000,\"\")\n\n\n    Thread(outake_2)\n    Thread(intaking)\n    Thread(third_prog)\ndef test():\n    drive_till(FORWARD,50,\"test\")\n    Drivetrain.stop()\n    print(\"DONE NOW\")\ndef when_started1():\n\n    # Drivetrain.stop()\n\n    brain_inertial.calibrate()\n    wait(0.75,SECONDS)\n    global myVariable, vexcode_brain_precision, vexcode_console_precision\n\n    Flywheel.set_velocity(200,PERCENT)\n    Flywheel.set_max_torque(200,PERCENT)\n    Drivetrain.set_velocity(drive_speed,PERCENT) \n    outtake.set_velocity(100,PERCENT)\n    outtake.set_max_torque(100, PERCENT)\n    touch.pressed(auton)\n\n    \n\n    # # while True:\n    # #     brain.screen.set_cursor(1, 1)\n\n       \n    # #     brain.screen.print(distance_2.object_distance(INCHES))\n    # #     wait(0.1,SECONDS) \n    # #     brain.screen.clear_screen()\n\n\n    #bumper_6.released(total_auton)\n    #bumper_6.released(part2)\n    #touchled_1.released(total_auton)\n    #controller.buttonEUp.pressed(intaking)\n    #controller.buttonFDown.pressed(motor_group_10)\n\nwhen_started1()\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"outtake","leftDir":"true","right":"Flywheel","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[8,12],"name":"Flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[10],"name":"touch","customName":true,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22},{"port":[7,9],"name":"outtake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"true","motor_b_reversed":"false"},"triportSourcePort":22},{"port":[3,4],"name":"Drivetrain","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}