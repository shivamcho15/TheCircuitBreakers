{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nDrivetrain_motor_a = Motor(Ports.PORT3, False)\nDrivetrain_motor_b = Motor(Ports.PORT4, True)\nDrivetrain = MotorGroup(Drivetrain_motor_a, Drivetrain_motor_b)\nouttake_motor_a = Motor(Ports.PORT9, False)\nouttake_motor_b = Motor(Ports.PORT7, True)\nouttake = MotorGroup(outtake_motor_a, outtake_motor_b)\nFlywheel_motor_a = Motor(Ports.PORT8, False)\nFlywheel_motor_b = Motor(Ports.PORT12, True)\nFlywheel = MotorGroup(Flywheel_motor_a, Flywheel_motor_b)\ntouchled_10 = Touchled(Ports.PORT10)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n\nturn_speed=50\ndrive_speed=75\ndrive_kp=1\n\nstop_driving=False\nstop_turning=False\n\n\nfirst_code_done=False\n\nauton_number=0\nintaking=False\ndef PID(cur,final,maxSpeed,minSpeed=3):\n\n    maxSpeedDuration = 0\n    if cur<final*maxSpeedDuration:\n        return maxSpeed\n    else:\n        speed = maxSpeed*(final-cur)/(final*(1-maxSpeedDuration))\n        \n        return max(speed,minSpeed)\ndef direction(subtract=False,toAdd=False):\n\n    head = brain_inertial.heading(DEGREES)\n    if subtract:\n        head = head-360\n    if toAdd:\n        head = head+360\n    if head<=180:\n        return head\n    else:\n        return head-360\ndef reverse_direction(head):\n    if head<0:\n        return head+360\n    else:\n        return head\ndef bound(x):\n    if x<=-180:\n        return x+360\n    if x>180:\n        return x-360\n    else:\n        return x\n\ndef drive_till(direct,dist,msg=\"\",sp=None,correct=True, reset=True):\n    print(\"STARTING TO MOVE\",direct,\":\",msg)\n    global drive_speed\n    global stop_driving\n    if sp==None:\n        sp=drive_speed\n    turn_angle = 360*dist/(13*25.4)\n    # brain_inertial.set_heading(0,DEGREES)\n\n    beginningRotation=brain_inertial.heading()\n    left_pos = Drivetrain_motor_a.position(DEGREES)\n\n    Drivetrain.set_velocity(sp,PERCENT)\n    if reset:\n        brain_inertial.set_heading(0,DEGREES)\n    print(\"Direct:\",direction())\n\n\n\n    # brain_inertial.set_heading(5,DEGREES)\n\n    if direct==FORWARD:\n        brain_inertial.heading()\n        while Drivetrain_motor_a.position(DEGREES) < left_pos+turn_angle:\n            \n            \n\n            # print(Drivetrain_motor_a.position(DEGREES),left_pos+turn_angle)\n            error = (direction())\n            # print(\"Error\",error)\n            \n            if correct:\n                error = error * drive_kp\n                # Drivetrain_motor_a.set_velocity(max(sp-error,0),PERCENT)\n                # Drivetrain_motor_b.set_velocity(max(sp+error,0),PERCENT)\n\n                Drivetrain_motor_a.spin(FORWARD,max(sp-error,0),PERCENT)\n                Drivetrain_motor_b.spin(FORWARD,max(sp+error,0),PERCENT)\n            else:\n                Drivetrain_motor_a.spin(FORWARD,sp,PERCENT)\n                Drivetrain_motor_b.spin(FORWARD,sp,PERCENT)\n\n            # print(\"Motor A:\",Drivetrain_motor_a.velocity(PERCENT))\n            # print(\"Motor B:\",Drivetrain_motor_b.velocity(PERCENT))\n            \n            \n            \n            # Drivetrain.spin(FORWARD)\n\n            if stop_driving:\n                stop_driving=False\n                break\n        print(\"DONE\")\n        Drivetrain.stop()\n    \n    if direct==REVERSE:\n        while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n            \n            \n\n            # print(Drivetrain_motor_a.position(DEGREES),left_pos+turn_angle)\n            # error = (direction())\n            # print(\"Error\",error)\n            \n\n            # error = error * drive_kp\n            # Drivetrain_motor_a.set_velocity(max(drive_speed-error,0))\n            # Drivetrain_motor_b.set_velocity(max(drive_speed+error,0))\n            # print(\"Motor A:\",max(drive_speed-error,0))\n            # print(\"Motor B:\",max(drive_speed+error,0))\n            \n            \n            Drivetrain.spin(REVERSE)\n\n            if stop_driving:\n                stop_driving=False\n                break\n        print(\"DONE\")\n    # if direct==REVERSE:\n    #     while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n\n    #         error = (direction())\n\n    #         error = error * drive_kp\n    #         print(\"Error\",error,\"Prev Error\",prevError)\n    #         Drivetrain_motor_a.set_velocity(max(drive_speed-error,0))\n    #         Drivetrain_motor_b.set_velocity(max(drive_speed+error,0))\n\n    #         print(\"MADE LEfT MOTOR\", drive_speed-error, \"RIGHT MOTOR\",drive_speed+error)\n    #         print(\"--------------------\")\n\n            \n            \n    #         Drivetrain.spin(REVERSE)\n    #         prevError=error\n\n    #     drive_speed=70\n    #     print(\"DONE\")\n\n    # Drivetrain.stop()\n        \n    newRotation = beginningRotation+direction()\n    brain_inertial.set_heading(reverse_direction(bound(newRotation)))\n\n    print(\"ENDING MOVE\",direct)\n\ndef turn_till(direct,dist,minVelocity=6,secondary=False,reset=False,left=None,right=None,pid=True):\n\n    global turn_speed\n\n    print(\"STARTING TURN\",direct)\n\n    Drivetrain.set_velocity(turn_speed,PERCENT)\n\n\n    # brain_inertial.set_heading(0,DEGREES)\n    if reset:\n        brain_inertial.set_heading(0,DEGREES)\n    ogRotation = direction()\n\n    leftSet=False\n    rightSet=False\n\n    print(direction())\n    if left!=None:\n        Drivetrain_motor_a.set_velocity(left,PERCENT)\n        leftSet=True\n    if right!=None:\n        rightSet=True\n        Drivetrain_motor_b.set_velocity(right,PERCENT)\n    if direct==RIGHT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        subtract=False\n        if(direction()>dist):\n            subtract=True\n\n        while direction(subtract)<dist:\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            if pid:\n                if not leftSet:\n                    Drivetrain_motor_a.set_velocity(PID(direction(subtract)-ogRotation,dist-ogRotation,turn_speed,minSpeed=minVelocity),PERCENT)\n                if not rightSet:\n                    Drivetrain_motor_b.set_velocity(PID(direction(subtract)-ogRotation,dist-ogRotation,turn_speed,minSpeed=minVelocity),PERCENT)\n            else:\n                Drivetrain.set_velocity(turn_speed,PERCENT)\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n            \n            Drivetrain_motor_a.spin(FORWARD)\n            Drivetrain_motor_b.spin(REVERSE)\n\n            # print(direction(subtract),dist)\n        # Drivetrain.stop()\n\n\n    if direct==LEFT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        add=False\n        if(direction()<dist):\n            add=True\n        # print(direction(toAdd=add),dist)\n\n        while direction(toAdd=add)>dist:\n            # print(direction(toAdd=add))\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            if (not add) and pid:\n                Drivetrain.set_velocity(PID(ogRotation-direction(toAdd=add),ogRotation-dist,turn_speed),PERCENT)\n            else:\n                Drivetrain.set_velocity(PID(direction(toAdd=add)-ogRotation,dist-ogRotation,turn_speed),PERCENT)\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n\n            Drivetrain_motor_a.spin(REVERSE)\n            Drivetrain_motor_b.spin(FORWARD)\n\n        # Drivetrain.stop()\n    Drivetrain.stop()\n\n    opposite_direction = RIGHT if direct == LEFT else LEFT\n    \n    print(\"DONE\")\n\n    print(\"ENDING TURN\",direct)\ndef jamDetection():\n    while True:\n        wait(1,SECONDS)\n        if(intaking):\n            if Flywheel.velocity(PERCENT)<5:\n                print(\"JAM DETECTED\")\n                Flywheel.spin(REVERSE)\n                wait(1,SECONDS)\n                Flywheel.spin(FORWARD)\ndef auton():\n    global auton_number\n    auton_number+=1\n    if auton_number==1:\n        right_greens()\n    if auton_number==2:\n        first_red()\n    elif auton_number==3:\n        left_greens()\n    elif auton_number==4:\n        get_back()\ndef left_greens():\n    def fly():\n        intaking=True\n        Flywheel.spin(FORWARD)\n        wait(10,SECONDS)\n        Flywheel.stop()\n        intaking=False\n    def movement():\n        drive_till(FORWARD,300,\"1\")\n        wait(0.5,SECONDS)\n\n        # No Cluster Code\n        drive_till(REVERSE,330)\n        drive_till(REVERSE,70,sp=40)\n        turn_till(RIGHT,70)\n        drive_till(REVERSE,100)\n\n        \n        # Cluster Code (DO NOT DELETE)\n        # turn_till(LEFT,-45)\n        # wait(0.25,SECONDS)\n        # drive_till(REVERSE,350,\"2\")\n        # wait(0.25,SECONDS)\n        # drive_till(FORWARD,220)\n        # wait(0.25,SECONDS)\n        # turn_till(LEFT,-90)\n        # drive_till(FORWARD,325,\"3\")\n\n        # #Collected cluster\n\n        # wait(0.5,SECONDS)\n        # turn_till(RIGHT,20)\n        # drive_till(FORWARD,20)\n        # drive_till(REVERSE,500,\"5\")\n        # Drivetrain.stop()\n\n        # drive_till(REVERSE,190,\"2\")\n        # turn_till(RIGHT,28)\n        # drive_till(REVERSE,450,\"3\")\n        # if direction()>3:\n        #     turn_till(LEFT,0)\n        # if direction()<-3:\n        #     turn_till(RIGHT,0)\n        # drive_till(FORWARD,600,\"4\",sp=30)\n\n    def out():\n        wait(5,SECONDS)\n        Drivetrain.stop()\n        outtake.spin_for(FORWARD,6,TURNS)\n\n        wait(1,SECONDS)\n        outtake.spin_for(REVERSE,6,TURNS)\n\n    Thread(movement)\n    Thread(fly)\n    Thread(out)\ndef get_back():\n    def fly():\n        intaking=True\n        Flywheel.spin(FORWARD)\n        wait(100,SECONDS)\n        Flywheel.stop()\n        intaking=False\n    def out():\n        wait(15.5,SECONDS)\n        \n        outtake.spin_for(FORWARD,6,TURNS)\n        stop_driving=True\n        Thread(park)\n        wait(0.5,SECONDS)\n        outtake.spin_for(REVERSE,6,TURNS)\n\n    def get_third():\n        drive_till(FORWARD,1600,reset=False)\n        turn_till(RIGHT,120)\n        drive_till(FORWARD,60)\n        drive_till(REVERSE,50)\n\n        turn_till(LEFT,80)\n        drive_till(FORWARD,50)\n        wait(1,SECONDS)\n        drive_till(FORWARD,250)\n        wait(0.5,SECONDS)\n    \n        drive_till(FORWARD,500)\n        # wait(0.5,SECONDS)\n        # drive_till(FORWARD,400)\n\n        turn_till(RIGHT,105)\n        # drive_till(REVERSE,400)\n        drive_till(REVERSE,900)\n        # turn_till(RIGHT,110)\n    def park():\n        turn_till(LEFT,90)\n        drive_till(FORWARD,1125)\n        turn_till(RIGHT,160)\n        turn_till(LEFT,110,pid=False)\n\n        drive_till(FORWARD,10000)\n\n    Thread(fly)\n    Thread(out)\n    Thread(get_third)\ndef first_red():\n    turn_till(RIGHT,45,pid=False)\ndef right_greens():\n    def out():\n        outtake_motor_a.spin_for(FORWARD,0.3,TURNS)\n        wait(6.5,SECONDS)\n        outtake.spin_for(FORWARD,6,TURNS)\n        wait(2,SECONDS)\n        outtake.spin_for(REVERSE,6,TURNS)\n        outtake_motor_a.spin_for(REVERSE,0.5,TURNS)\n\n    def fly():\n        intaking=True\n        Flywheel.spin(FORWARD)\n        wait(8,SECONDS)\n        Flywheel.stop()\n        intaking=False\n    # def purple_out():\n    #     outtake.spin_for(FORWARD,2,TURNS)\n    def get_greens():\n        drive_till(FORWARD,690,\"1\")\n\n        Drivetrain.stop()\n\n        wait(0.5,SECONDS)\n\n        # No Cluster Code\n        \n        drive_till(REVERSE,750)\n        turn_till(LEFT,-75)\n        drive_till(REVERSE,400)\n        Drivetrain.stop()\n        # Cluster Code (DO NOT DELETE)\n        # drive_till(REVERSE,162,\"2\")\n        # turn_till(RIGHT,90)\n        # drive_till(FORWARD,100)\n        # wait(0.5,SECONDS)\n        # drive_till(FORWARD,300)\n\n\n    \n\n        # #Collected cluster\n\n        # turn_till(LEFT,-15)\n        # # drive_till(FORWARD,50,\"4\")\n        # # wait(0.5,SECONDS)\n        # drive_till(REVERSE,200,\"5\")\n        # drive_till(REVERSE,200)\n        # Drivetrain.stop()\n    Thread(fly)\n    Thread(out)\n    Thread(get_greens)\ndef when_started():\n    jamDetection\n    brain_inertial.calibrate()\n    wait(0.75,SECONDS)\n    Flywheel.set_velocity(100,PERCENT)\n    outtake.set_velocity(100,PERCENT)\n    Drivetrain.set_velocity(drive_speed,PERCENT)\n    touchled_10.pressed(auton)\nwhen_started()","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[3,4],"name":"Drivetrain","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[9,7],"name":"outtake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[8,12],"name":"Flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[10],"name":"touchled_10","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}