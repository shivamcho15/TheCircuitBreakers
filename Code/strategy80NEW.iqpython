{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\ncontroller = Controller()\nDrivetrain_motor_a = Motor(Ports.PORT3, False)\nDrivetrain_motor_b = Motor(Ports.PORT4, True)\nDrivetrain = MotorGroup(Drivetrain_motor_a, Drivetrain_motor_b)\nouttake_motor_a = Motor(Ports.PORT9, False)\nouttake_motor_b = Motor(Ports.PORT7, True)\nouttake = MotorGroup(outtake_motor_a, outtake_motor_b)\nFlywheel_motor_a = Motor(Ports.PORT8, False)\nFlywheel_motor_b = Motor(Ports.PORT12, True)\nFlywheel = MotorGroup(Flywheel_motor_a, Flywheel_motor_b)\ntouchled_10 = Touchled(Ports.PORT10)\n\n\n\n# Make random actually random\ndef setRandomSeedUsingAccel():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    urandom.seed(int(xaxis + yaxis + zaxis))\n    \n# Set random seed \nsetRandomSeedUsingAccel()\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n# \tAuthor:       VEX\n# \tCreated:\n# \tDescription:  VEXcode IQ Python Project\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n\nturn_speed=50\ndrive_speed=60\ndrive_kp=1\n\nstop_driving=False\nstop_turning=False\n\n\nfirst_code_done=False\n\nauton_number=0\nintaking=False\ndef PID(cur,final,maxSpeed,minSpeed=3):\n\n    maxSpeedDuration = 0\n    if cur<final*maxSpeedDuration:\n        return maxSpeed\n    else:\n        speed = maxSpeed*(final-cur)/(final*(1-maxSpeedDuration))\n        \n        return max(speed,minSpeed)\ndef direction(subtract=False,toAdd=False):\n\n    head = brain_inertial.heading(DEGREES)\n    if subtract:\n        head = head-360\n    if toAdd:\n        head = head+360\n    if head<=180:\n        return head\n    else:\n        return head-360\ndef reverse_direction(head):\n    if head<0:\n        return head+360\n    else:\n        return head\ndef bound(x):\n    if x<=-180:\n        return x+360\n    if x>180:\n        return x-360\n    else:\n        return x\ndef hit_fast(direction,sec):\n    Drivetrain.set_velocity(100,PERCENT)\n    Drivetrain_motor_a.spin(FORWARD if direction==RIGHT else REVERSE)\n    Drivetrain_motor_b.spin(FORWARD if direction==LEFT else REVERSE)\n    wait(sec,SECONDS)\n    Drivetrain.stop()\ndef drive_till(direct,dist,msg=\"\",sp=None,correct=True, reset=True,shouldStop=False,whilemsg=\"\",stopTime=2):\n    print(\"STARTING TO MOVE\",direct,\":\",msg,\"FOR\",dist)\n    global drive_speed\n    global stop_driving\n    if sp==None:\n        sp=drive_speed\n    dist=dist * 3/4\n    turn_angle = 360*dist/(13*25.4)\n    # brain_inertial.set_heading(0,DEGREES)\n\n\n    beginningRotation=brain_inertial.heading()\n    left_pos = Drivetrain_motor_a.position(DEGREES)\n\n    Drivetrain.set_velocity(sp,PERCENT)\n    if reset:\n        brain_inertial.set_heading(0,DEGREES)\n    print(\"Direct:\",direction())\n    brain.timer.clear()\n\n\n\n    # brain_inertial.set_heading(5,DEGREES)\n\n    if direct==FORWARD:\n        brain_inertial.heading()\n        while Drivetrain_motor_a.position(DEGREES) < left_pos+turn_angle:\n            if whilemsg!=\"\":\n                print(whilemsg)\n\n            # print(Drivetrain_motor_a.position(DEGREES),left_pos+turn_angle)\n            error = (direction())\n            # print(\"Error\",error)\n            \n            if correct:\n                error = error * drive_kp\n                # Drivetrain_motor_a.set_velocity(max(sp-error,0),PERCENT)\n                # Drivetrain_motor_b.set_velocity(max(sp+error,0),PERCENT)\n\n                Drivetrain_motor_a.spin(FORWARD,max(sp-error,0),PERCENT)\n                Drivetrain_motor_b.spin(FORWARD,max(sp+error,0),PERCENT)\n            else:\n                Drivetrain_motor_a.spin(FORWARD,sp,PERCENT)\n                Drivetrain_motor_b.spin(FORWARD,sp,PERCENT)\n\n            # print(\"Motor A:\",Drivetrain_motor_a.velocity(PERCENT))\n            # print(\"Motor B:\",Drivetrain_motor_b.velocity(PERCENT))\n            \n            \n            \n            # Drivetrain.spin(FORWARD)\n\n            if stop_driving:\n                stop_driving=False\n                break\n        print(\"DONE\")\n        Drivetrain.stop()\n    \n    if direct==REVERSE:\n        while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n            \n            if whilemsg!=\"\":\n                print(whilemsg)\n\n\n            \n            if not shouldStop or (shouldStop and brain.timer.time(SECONDS)<stopTime):\n                Drivetrain.spin(REVERSE)\n            else:\n                Drivetrain.stop()\n                break\n            \n\n            if stop_driving:\n                stop_driving=False\n                print(\"STOPPED dRIVING\")\n                break\n            if shouldStop:\n                if brain.timer.time(SECONDS)>2:\n                    Drivetrain.stop()\n                    break\n        print(\"DONE\")\n        Drivetrain.stop()\n    # if direct==REVERSE:\n    #     while Drivetrain_motor_a.position(DEGREES) > left_pos-turn_angle:\n\n    #         error = (direction())\n\n    #         error = error * drive_kp\n    #         print(\"Error\",error,\"Prev Error\",prevError)\n    #         Drivetrain_motor_a.set_velocity(max(drive_speed-error,0))\n    #         Drivetrain_motor_b.set_velocity(max(drive_speed+error,0))\n\n    #         print(\"MADE LEfT MOTOR\", drive_speed-error, \"RIGHT MOTOR\",drive_speed+error)\n    #         print(\"--------------------\")\n\n            \n            \n    #         Drivetrain.spin(REVERSE)\n    #         prevError=error\n\n    #     drive_speed=70\n    #     print(\"DONE\")\n\n    # Drivetrain.stop()\n        \n    newRotation = beginningRotation+direction()\n    brain_inertial.set_heading(reverse_direction(bound(newRotation)))\n\n    print(\"ENDING MOVE\",direct)\n\ndef turn_till(direct,dist,minVelocity=6,secondary=False,reset=False,left=None,right=None,pid=True,checkVelocity=False,no180=False,stopTime=False):\n\n    global turn_speed\n\n    print(\"STARTING TURN\",direct,\"TO\",dist,\"currently\",direction())\n\n    Drivetrain.set_velocity(turn_speed,PERCENT)\n\n\n    # brain_inertial.set_heading(0,DEGREES)\n    if reset:\n        brain_inertial.set_heading(0,DEGREES)\n    ogRotation = direction()\n\n    if no180 and ogRotation>dist and direct==RIGHT:\n        return\n    elif no180 and ogRotation<dist and direct==LEFT:\n        return\n\n    leftSet=False\n    rightSet=False\n    brain.timer.clear()\n    ogTime=brain.timer.time(SECONDS)\n    print(direction())\n    if left!=None:\n        Drivetrain_motor_a.set_velocity(left,PERCENT)\n        leftSet=True\n    if right!=None:\n        rightSet=True\n        Drivetrain_motor_b.set_velocity(right,PERCENT)\n    if direct==RIGHT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        subtract=False\n        if(direction()>dist):\n            subtract=True\n\n        while direction(subtract)<dist:\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            if pid:\n                if not leftSet:\n                    Drivetrain_motor_a.set_velocity(max(PID(direction(subtract)-ogRotation,dist-ogRotation,turn_speed,minSpeed=minVelocity),minVelocity),PERCENT)\n                if not rightSet:\n                    Drivetrain_motor_b.set_velocity(max(PID(direction(subtract)-ogRotation,dist-ogRotation,turn_speed,minSpeed=minVelocity),minVelocity),PERCENT)\n            else:\n                Drivetrain.set_velocity(turn_speed,PERCENT)\n            if checkVelocity and brain.timer.time(SECONDS)-ogTime>0.25 and Drivetrain.velocity(PERCENT)<5:\n                break\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n            \n            Drivetrain_motor_a.spin(FORWARD)\n            Drivetrain_motor_b.spin(REVERSE)\n\n            if stopTime!=False and brain.timer.time(SECONDS)>stopTime:\n                break\n\n            # print(direction(subtract),dist)\n        # Drivetrain.stop()\n\n\n    if direct==LEFT:\n        print(\"STARTED\")\n        # brain_inertial.set_heading(0,DEGREES)\n        add=False\n        if(direction()<dist):\n            add=True\n        # print(direction(toAdd=add),dist)\n\n        while direction(toAdd=add)>dist:\n            # print(direction(toAdd=add))\n            # print(direction())\n            # print(PID(direction(),dist,70))\n            if (not add) and pid:\n                Drivetrain.set_velocity(PID(ogRotation-direction(toAdd=add),ogRotation-dist,turn_speed),PERCENT)\n            else:\n                Drivetrain.set_velocity(PID(direction(toAdd=add)-ogRotation,dist-ogRotation,turn_speed),PERCENT)\n            # Drivetrain.set_velocity(turn_speed,PERCENT)\n            # print(\"SPINNING\")\n\n            Drivetrain_motor_a.spin(REVERSE)\n            Drivetrain_motor_b.spin(FORWARD)\n\n            if stopTime!=False and brain.timer.time(SECONDS)>stopTime:\n                break\n\n        # Drivetrain.stop()\n    Drivetrain.stop()\n\n    opposite_direction = RIGHT if direct == LEFT else LEFT\n    \n    print(\"DONE\")\n\n    print(\"ENDING TURN\",direct,\".Wanted\",dist,\"and ended up with\",direction())\ndef jamDetection():\n    return\n    # while True:\n    #     wait(1,SECONDS)\n    #     if(intaking and False):\n    #         if Flywheel.velocity(PERCENT)<5:\n    #             print(\"JAM DETECTED\")\n    #             Flywheel.spin(REVERSE)\n    #             wait(1,SECONDS)\n    #             Flywheel.spin(FORWARD)\ndef auton():\n    global auton_number, stop_driving\n    auton_number+=1\n\n\n    def flywheel_movement():\n    \n        Flywheel.spin(FORWARD)\n        wait(180,SECONDS)\n        Flywheel.stop()\n    if auton_number==1:\n        Thread(flywheel_movement)\n    if auton_number==6 and False:\n        testing()\n        return\n    if auton_number==1:\n        left_greens()\n    if auton_number==2:\n        get_back()\n    elif auton_number==3:\n        first_red_park()\n    elif auton_number==4:\n        right_greens()\n#TODO LIST:\ndef left_greens():\n    def fly():\n        return\n    def movement():\n        # drive_till(FORWARD,690,msg=\"337\")\n        # drive_till(REVERSE,400,msg=\"338\")\n\n        # Drivetrain.stop()\n\n        # wait(0.5,SECONDS)\n\n        \n\n        # # Cluster Code (DO NOT DELETE)\n\n        # # drive_till(REVERSE,162,\"2\")\n        \n        # turn_till(LEFT,-22)\n        # drive_till(FORWARD,300,msg=\"351\")\n        drive_till(FORWARD,700)\n        drive_till(RIGHT,-15,msg=\"352\")\n        drive_till(FORWARD,400,msg=\"353\") \n\n\n\n    \n\n        # #Collected cluster\n\n        turn_speed=90\n        turn_till(RIGHT,25,minVelocity=7,stopTime=1.5)\n        turn_speed=50\n        # drive_till(FORWARD,50,\"4\")\n        # wait(0.5,SECONDS)\n\n        \n        drive_till(REVERSE,375,msg=\"369\")\n        turn_till(RIGHT,12.5,no180=True)\n        drive_till(REVERSE,375)\n        drive_till(REVERSE,25)\n\n        Drivetrain.stop()\n    def out():\n        wait(5,SECONDS)\n        Drivetrain.stop()\n        outtake.spin_for(FORWARD,6,TURNS)\n\n\n        wait(1,SECONDS)\n        outtake.spin_for(REVERSE,6,TURNS)\n\n\n    Thread(movement)\n    Thread(fly)\n    Thread(out)\ndef move_forward():\n    print(\"MOVING FORWARD AFTER OUTTAKIG ON LIE NUMBER 383\")\n    while True:\n        Drivetrain.spin(FORWARD)\ndef get_back():\n    global start_driving\n    print(\"STARTING THE BACKKKKKKKKKKK\")\n    def fly():\n        return\n    def out():\n        wait(16,SECONDS)\n        \n        outtake.spin_for(FORWARD,6,TURNS)\n        stop_driving=True\n        wait(1.5,SECONDS)\n\n        drive_till(FORWARD,25)\n        drive_till(REVERSE,25)\n        # Thread(park)\n        wait(0.5,SECONDS)\n        # turn_till(RIGHT,30)\n        # drive_till(FORWARD,300)\n        outtake.spin_for(REVERSE,6,TURNS)\n\n    def get_third():\n        global stop_driving\n        # drive_till(FORWARD,1600,reset=False)\n        # turn_till(RIGHT,130)\n        # drive_till(FORWARD,60)\n        # drive_till(REVERSE,50)\n\n        # turn_till(LEFT,80)\n        # drive_till(FORWARD,50)\n        # wait(1,SECONDS)\n        # drive_till(FORWARD,250)\n        # wait(0.5,SECONDS)\n    \n        # drive_till(FORWARD,500)\n        # # wait(0.5,SECONDS)\n        # # drive_till(FORWARD,400)\n\n        # turn_till(RIGHT,105)\n        # # drive_till(REVERSE,400)\n        # drive_till(REVERSE,900)\n        # # turn_till(RIGHT,110)\n        if stop_driving==True:\n            stop_driving=False\n        # drive_till(FORWARD,700)\n        drive_till(FORWARD,1300,msg=\"433\")\n\n        turn_till(RIGHT,37,no180=True)\n\n        drive_till(FORWARD,150,msg=\"438\")\n        # turn_till(RIGHT,170,no180=True,stopTime=1.7)\n        # turn_till(LEFT,47)\n\n\n\n        drive_till(FORWARD,450,msg=\"441\")\n\n        turn_till(RIGHT,67,no180=True)\n        drive_till(FORWARD,150,msg=\"444\")\n\n        turn_till(RIGHT,76,no180=True)\n        drive_till(FORWARD,200,msg=\"447\")\n        hit_fast(RIGHT,1)\n        \n        turn_till(LEFT,90,no180=True)\n        drive_till(FORWARD,300,msg=\"450\")\n\n        wait(0.5,SECONDS)\n        turn_till(RIGHT,103,no180=True,stopTime=2)\n        drive_till(REVERSE,800,msg=\"454\")\n        turn_till(RIGHT,105,no180=True,stopTime=2)\n        drive_till(REVERSE,500,msg=\"456\")\n        turn_till(RIGHT,95,no180=True,stopTime=2)\n        drive_till(REVERSE,300)\n\n\n    Thread(fly)\n    Thread(out)\n    Thread(get_third)\ndef first_red_park():\n    drive_till(FORWARD,40)\n    turn_till(LEFT,-50,no180=True,minVelocity=40)\n\ndef testing():\n    drive_till(REVERSE,30000,msg=\"468\",shouldStop=True)\ndef right_greens():\n    def out():\n        outtake_motor_b.spin_for(FORWARD,1.25,TURNS)\n        wait(12,SECONDS)\n\n        outtake.spin_for(FORWARD,6,TURNS)\n        stop_driving=True\n        # drive_till(E)\n        # drive_till(UR MOMS HOUSE)\n        Drivetrain.stop()\n        move_forward()\n        # outtake.spin_for(REVERSE,6,TURNS)\n\n    def fly():\n        return\n        intaking=False\n    # def purple_out():\n    #     outtake.spin_for(FORWARD,2,TURNS)\n    def get_greens():\n        drive_till(FORWARD,690,msg=\"492\")\n        wait(0.25,SECONDS)\n        drive_till(REVERSE,460,msg=\"493\")\n\n        Drivetrain.stop()\n\n\n        \n\n        # Cluster Code (DO NOT DELETE)\n\n        # drive_till(REVERSE,162,\"2\")\n        \n        turn_till(RIGHT,25,no180=True)\n        drive_till(FORWARD,200,msg=\"505\")\n        turn_till(RIGHT,30,no180=True)\n        drive_till(FORWARD,220,msg=\"505\")\n\n\n        # drive_till(REVERSE,25)\n        wait(0.5,SECONDS)\n\n\n\n    \n\n        # #Collected cluster\n\n        turn_till(RIGHT,90,no180=True)\n        # drive_till(FORWARD,50,\"4\")\n        # wait(0.5,SECONDS)\n\n        drive_till(FORWARD,270,msg=\"MOVING RN TOWARDS WALL\")\n        turn_till(LEFT,-24,no180=True,minVelocity=100)\n        drive_till(REVERSE,400,shouldStop=True,whilemsg=\"FIRST MOVING BACK\")\n\n\n        # drive_till(REVERSE,600,shouldStop=True,msg=\"MOVING BACK A LOT RN\",whilemsg=\"STILL MOVING BACK\",stopTime=2.5)\n\n        \n        Drivetrain.stop()\n\n        # drive_till(REVERSE,500,\"5\")\n        # Drivetrain.stop()\n        # wait(0.5,SECONDS)\n        # turn_till(RIGHT,-39,no180=True)\n        # turn_till(LEFT,-20,no180=True)\n        # drive_till(REVERSE,800)\n        Drivetrain.stop()\n    Thread(fly)\n    Thread(out)\n    Thread(get_greens)\ndef when_started():\n    Thread(jamDetection)\n    brain_inertial.calibrate()\n    wait(0.75,SECONDS)\n    Flywheel.set_velocity(100,PERCENT)\n    outtake.set_velocity(100,PERCENT)\n    Drivetrain.set_velocity(drive_speed,PERCENT)\n    touchled_10.pressed(auton)\nwhen_started()\n\n\n","textLanguage":"python","rconfig":[{"port":[],"name":"controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[3,4],"name":"Drivetrain","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[9,7],"name":"outtake","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[8,12],"name":"Flywheel","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"},"triportSourcePort":22},{"port":[10],"name":"touchled_10","customName":false,"deviceType":"TouchLED","deviceClass":"touchled","setting":{},"triportSourcePort":22}],"slot":1,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}